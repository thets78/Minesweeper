@page "/gamefield"
@rendermode InteractiveServer
@implements IDisposable

<div class="container">
<div class="row justify-content-center">
@if (!initialized)
{
    <div class="spinner-border text-primary" role="status">
        <span class="sr-only">Loading...</span>
    </div>
}
else
{
    <div class="game__grid @GetAdditionalGridClass()" style="@GridStyle()">
        @foreach (var square in _shuffledSquares)
        {
            <div id="@square.Id" class="@square.Class" style="@GridCellStyle()" @onclick="(() => OnClick(square))" @oncontextmenu="(() => OnRightClick(square))" @oncontextmenu:preventDefault="true">
                @if(square.IsRevealed && square.Type == GameGridSquareType.Number && square.AdjacentMineCount > 0)
                {
                    <div style="font-size: calc(max(10px, 1vw));">@square.AdjacentMineCount</div>
                }
            </div>
        }
    </div>
    @if(_game.GameState == GameState.InProgress)
    {
        <div class="row justify-content-center">
            <div class="col">
                <span class="me-2">Flags left:</span>
                <span class="me-2">@FlagsLeft</span>
            </div>
            <div class="col">
                <span class="me-2">Time:</span>
                <span class="me-2">@clock</span>
            </div>
        </div>

        <div class="row justify-content-center mt-2 mb-2">
            <button class="btn col-6 btn-primary" @onclick="(() => ResetGame())">Reset Game</button>
        </div>
    }
    @if(_game.GameState == GameState.Won)
    {
        <div class="alert alert-success" role="alert">
            <div class="d-flex p-2 justify-content-center">
                <span class="d-flex me-3">You won!</span>
                <span>@_game.Time.ToString(@"hh\:mm\:ss")</span>
            </div>
        </div>
    }
    @if(_game.GameState == GameState.Lost)
    {
        <div class="alert alert-danger" role="alert">
            <div class="d-flex p-2 justify-content-center">
                <span class="d-flex me-3">You lost!</span>
                <span>@_game.Time.ToString(@"hh\:mm\:ss")</span>
            </div>
        </div>
    }
}
</div>
    
</div>


@code {
    [Parameter] public Game? Game { get; set; }
    private Game _game = Game.SetupGame(GameType.Easy);
    [Parameter] public EventCallback<GameState> OnGameStateChanged { get; set; }
    [Parameter] public EventCallback<Game> OnGameChanged { get; set; }

    bool gameOver = false;
    bool gameWin = false;
    bool initialized = false;
    Timer? clockTimer;

    private List<GameGridSquare> _shuffledSquares = new List<GameGridSquare>();

    private int usedFlags = 0;
    private int FlagsLeft { get { return (_game.MineCount != 0) ? _game.MineCount - usedFlags : 0; } }
    private int TotalSquares { get { return (_game.GridWidth != 0) ? _game.GridWidth * _game.GridHeight : 0; } }
    private int ReveledSquares { get { return _shuffledSquares.Where(x => x.IsRevealed).Count(); } }
    private string clock = "00:00:00";
    private DateTime startTime = DateTime.Now;

    // methods
    void IDisposable.Dispose()
    {
        clockTimer?.Dispose();
        clockTimer = null;
    }

    protected override async Task OnInitializedAsync()
    {
        // Simulate asynchronous loading to demonstrate streaming rendering
        // await Task.Delay(500);

        if (Game != null)
        {
            _game = Game;
        }
        else
        {
            _game = Game.SetupGame(GameType.Easy);
        }

        // Shuffle the squares
        await ResetGame();

        Console.WriteLine("Gamefield initialized");

        initialized = true;
    }

    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();

        if (Game != null && (_game.GameType != Game?.GameType || _game != Game))
        {
            _game = Game!;
            Console.WriteLine("--- GameField - OnParametersSetAsync ----------------------------------------------------");
            Console.WriteLine($"GridWidth: {_game.GridWidth}, GridHeight: {_game.GridHeight}, TotalMines: {_game.MineCount}, GameType: {_game.GameType}");
            await ResetGame();
        }
    }

    private string GridStyle()
    {
        return $"width: {_game.GridWidth * 2}vw; height: {_game.GridHeight * 2}vw; min-width: {_game.GridWidth * 18}px; min-height: {_game.GridHeight * 18}px;";
    }

    private string GridCellStyle()
    {
        return $"width: 2vw; height: 2vw; min-width: 18px; min-height: 18px;";
    }

    private string GetAdditionalGridClass()
    {
        if (_game.GameType == GameType.Easy)
        {
            return $"";
        }
        if (_game.GameType == GameType.Medium)
        {
            return "medium";
        }
        if (_game.GameType == GameType.Hard)
        {
            return "hard";
        }
        return "";
    }
    public async Task ResetGame()
    {
        gameOver = false;
        gameWin = false;

        usedFlags = 0;

        _shuffledSquares = GetShuffledSquareList(_game.MineCount, TotalSquares);

        foreach (var square in _shuffledSquares)
        {
            square.IsRevealed = false;
            square.IsFlagged = false;
            square.IsChecked = false;
            square.AdjacentMineCount = 0;
        }

        // Count adjacent mines
        CountAdjacentMines(_shuffledSquares, _game.GridWidth);
        startTime = DateTime.Now;
        clockTimer = new System.Threading.Timer((_) =>
        {
            UpdateClock();
            InvokeAsync(() =>
            {
                StateHasChanged();
            });
        }, null, 0, 250);

        await OnGameStateChanged.InvokeAsync(GameState.InProgress);
    }

    private List<GameGridSquare> GetShuffledSquareList(int totalMines, int totalSquares)
    {
        Console.WriteLine("--- GetShuffledSquareList ---------------------------------------------------------------");
        Console.WriteLine($"TotalMines: {totalMines}, TotalSquares: {totalSquares}");

        List<GameGridSquare> list = new List<GameGridSquare>();
        
        // Initialize the mines
        for (int i = 0; i < totalMines; i++)
        {
            list.Add(new GameGridSquare() { Id = list.Count, Type = GameGridSquareType.Mine, IsRevealed = false });
        }
        // Initialize the squares
        for (int i = 0; i < totalSquares - totalMines; i++)
        {
            list.Add(new GameGridSquare() { Id = list.Count, Type = GameGridSquareType.Empty, IsRevealed = false });
        }

        list = list.OrderBy(x => Guid.NewGuid()).ToList();
        foreach (var square in list)
        {
            square.Id = list.IndexOf(square);
        }
        return list;
    }

    private void CountAdjacentMines(List<GameGridSquare> gridSquares, int gridWidth)
    {
        foreach (var square in gridSquares)
        {
            int adjacentMines = 0;
            if (square.Type == GameGridSquareType.Mine)
            {
                continue;
            }
            // check left
            if (square.Id % gridWidth != 0)
            {
                if (gridSquares[square.Id - 1].Type == GameGridSquareType.Mine)
                {
                    adjacentMines++;
                }
            }
            // check right
            if (square.Id % gridWidth != gridWidth - 1)
            {
                if (gridSquares[square.Id + 1].Type == GameGridSquareType.Mine)
                {
                    adjacentMines++;
                }
            }
            // check top
            if (square.Id >= gridWidth)
            {
                if (gridSquares[square.Id - gridWidth].Type == GameGridSquareType.Mine)
                {
                    adjacentMines++;
                }
            }
            // check bottom
            if (square.Id < gridSquares.Count - gridWidth)
            {
                if (gridSquares[square.Id + gridWidth].Type == GameGridSquareType.Mine)
                {
                    adjacentMines++;
                }
            }
            // check top left
            if (square.Id % gridWidth != 0 && square.Id >= gridWidth)
            {
                if (gridSquares[square.Id - gridWidth - 1].Type == GameGridSquareType.Mine)
                {
                    adjacentMines++;
                }
            }
            // check top right
            if (square.Id % gridWidth != gridWidth - 1 && square.Id >= gridWidth)
            {
                if (gridSquares[square.Id - gridWidth + 1].Type == GameGridSquareType.Mine)
                {
                    adjacentMines++;
                }
            }
            // check bottom left
            if (square.Id % gridWidth != 0 && square.Id < gridSquares.Count - gridWidth)
            {
                if (gridSquares[square.Id + gridWidth - 1].Type == GameGridSquareType.Mine)
                {
                    adjacentMines++;
                }
            }
            // check bottom right
            if (square.Id % gridWidth != gridWidth - 1 && square.Id < gridSquares.Count - gridWidth)
            {
                if (gridSquares[square.Id + gridWidth + 1].Type == GameGridSquareType.Mine)
                {
                    adjacentMines++;
                }
            }
            if (adjacentMines > 0)
            {
                square.Type = GameGridSquareType.Number;
                square.AdjacentMineCount = adjacentMines;
            }
        }
    }

    private async Task CheckNeighbours(GameGridSquare square, List<GameGridSquare> gridSquares, int gridWidth)
    {
        // check left
        if (square.Id % gridWidth != 0)
        {
            await OnClick(gridSquares[square.Id - 1]);
        }
        // check right
        if (square.Id % gridWidth != gridWidth - 1)
        {
            await OnClick(gridSquares[square.Id + 1]);
        }
        // check top
        if (square.Id >= gridWidth)
        {
            await OnClick(gridSquares[square.Id - gridWidth]);
        }
        // check bottom
        if (square.Id < gridSquares.Count - gridWidth)
        {
            await OnClick(gridSquares[square.Id + gridWidth]);
        }
        // check top left
        if (square.Id % gridWidth != 0 && square.Id >= gridWidth)
        {
            await OnClick(gridSquares[square.Id - gridWidth - 1]);
        }
        // check top right
        if (square.Id % gridWidth != gridWidth - 1 && square.Id >= gridWidth)
        {
            await OnClick(gridSquares[square.Id - gridWidth + 1]);
        }
        // check bottom left
        if (square.Id % gridWidth != 0 && square.Id < gridSquares.Count - gridWidth)
        {
            await OnClick(gridSquares[square.Id + gridWidth - 1]);
        }
        // check bottom right
        if (square.Id % gridWidth != gridWidth - 1 && square.Id < gridSquares.Count - gridWidth)
        {
            await OnClick(gridSquares[square.Id + gridWidth + 1]);
        }
    }

    private async Task EndGame(bool win)
    {
        gameOver = true;
        gameWin = win;

        _game.GameState = win ? GameState.Won : GameState.Lost;
        _game.Time = DateTime.Now - startTime;
        await OnGameChanged.InvokeAsync(_game);

        foreach (var item in _shuffledSquares)
        {
            item.IsRevealed = true;
        }
        clockTimer?.Dispose();
        clockTimer = null;
    }

    private async Task OnClick(GameGridSquare square)
    {
        if (square.IsRevealed || square.IsFlagged || square.IsChecked || gameOver)
        {
            return;
        }

        square.IsRevealed = true;
        Console.WriteLine($"OnClick: square: ID {square.Id} Type: {square.Type} AdjCount: {square.AdjacentMineCount} IsRevealed: {square.IsRevealed}");

        if (square.Type == GameGridSquareType.Mine)
        {
            await EndGame(false);
            return;
        }
        if (ReveledSquares == TotalSquares - _game.MineCount)
        {
            await EndGame(true);
            return;
        }

        if (square.Type == GameGridSquareType.Empty)
        {
            await CheckNeighbours(square, _shuffledSquares, _game.GridWidth);
        }
    }

    private void OnRightClick(GameGridSquare square)
    {
        if (square.IsRevealed || gameOver)
        {
            return;
        }

        if (!square.IsFlagged /*&& !square.IsChecked*/ && usedFlags < _game.MineCount)
        {
            square.IsFlagged = true;
            usedFlags++;
        }
        else if (square.IsFlagged)
        {
            square.IsFlagged = false;
            //square.IsChecked = true;
            usedFlags--;
        }
        else
        {
            square.IsFlagged = false;
            square.IsChecked = false;
        }
    }

    private string GameClassification()
    {
        if (_game.GameType == GameType.Easy)
        {
            return "Easy game";
        }
        else if (_game.GameType == GameType.Medium)
        {
            return "Medium game";
        }
        else if(_game.GameType == GameType.Hard)
        {
            return "Hard game";
        }

        return "No game";
    }


    private void UpdateClock()
    {
        TimeSpan diffTime = DateTime.Now - startTime;
        clock = diffTime.ToString(@"hh\:mm\:ss");
    }
}
